//! PlantVillage Semi-Supervised Learning CLI
//!
//! This is the main entry point for the PlantVillage plant disease classification
//! system using semi-supervised learning with the Burn framework.

use std::path::Path;

use anyhow::Result;
use clap::{Parser, Subcommand};
use colored::Colorize;
use tracing::info;

use plantvillage_ssl::dataset::{
    PlantVillageBatcher, PlantVillageBurnDataset, PlantVillageDataset, SplitConfig,
    DatasetSplits,
};
use plantvillage_ssl::model::config::SemiSupervisedConfig;
use plantvillage_ssl::utils::logging::{init_logging, LogConfig};

/// PlantVillage Semi-Supervised Plant Disease Classification
///
/// A Rust-based semi-supervised learning system for plant disease classification
/// using the Burn framework, designed for deployment on edge devices like the
/// NVIDIA Jetson Orin Nano.
#[derive(Parser, Debug)]
#[command(name = "plantvillage_ssl")]
#[command(author = "Warre Snaet")]
#[command(version = "0.1.0")]
#[command(about = "Semi-supervised plant disease classification with Burn", long_about = None)]
struct Cli {
    /// Enable verbose logging
    #[arg(short, long, default_value = "false")]
    verbose: bool,

    /// Subcommand to execute
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Download and prepare the PlantVillage dataset
    Download {
        /// Output directory for the dataset
        #[arg(short, long, default_value = "data/plantvillage")]
        output_dir: String,
    },

    /// Train the model with semi-supervised learning
    Train {
        /// Path to the dataset directory
        #[arg(short, long, default_value = "data/plantvillage")]
        data_dir: String,

        /// Number of training epochs
        #[arg(short, long, default_value = "50")]
        epochs: usize,

        /// Batch size for training
        #[arg(short, long, default_value = "32")]
        batch_size: usize,

        /// Learning rate
        #[arg(short, long, default_value = "0.001")]
        learning_rate: f64,

        /// Percentage of labeled data (0.0-1.0)
        #[arg(long, default_value = "0.2")]
        labeled_ratio: f64,

        /// Confidence threshold for pseudo-labeling (0.0-1.0)
        #[arg(long, default_value = "0.9")]
        confidence_threshold: f64,

        /// Output directory for model checkpoints
        #[arg(short, long, default_value = "output/models")]
        output_dir: String,

        /// Use CUDA backend
        #[arg(long, default_value = "false")]
        cuda: bool,

        /// Random seed for reproducibility
        #[arg(long, default_value = "42")]
        seed: u64,
    },

    /// Run inference on a single image or directory
    Infer {
        /// Path to input image or directory
        #[arg(short, long)]
        input: String,

        /// Path to trained model
        #[arg(short, long)]
        model: String,

        /// Use CUDA backend
        #[arg(long, default_value = "false")]
        cuda: bool,
    },

    /// Benchmark inference performance
    Benchmark {
        /// Path to trained model
        #[arg(short, long)]
        model: String,

        /// Path to test images directory
        #[arg(short, long, default_value = "data/plantvillage/test")]
        test_dir: String,

        /// Number of inference iterations for timing
        #[arg(short, long, default_value = "100")]
        iterations: usize,

        /// Use CUDA backend
        #[arg(long, default_value = "false")]
        cuda: bool,
    },

    /// Simulate streaming data for semi-supervised learning demo
    Simulate {
        /// Path to the dataset directory
        #[arg(short, long, default_value = "data/plantvillage")]
        data_dir: String,

        /// Path to trained model (for starting point)
        #[arg(short, long)]
        model: String,

        /// Number of simulated days
        #[arg(long, default_value = "30")]
        days: usize,

        /// Images per day
        #[arg(long, default_value = "50")]
        images_per_day: usize,

        /// Confidence threshold for pseudo-labeling
        #[arg(long, default_value = "0.9")]
        confidence_threshold: f64,

        /// Retrain after this many pseudo-labeled images
        #[arg(long, default_value = "200")]
        retrain_threshold: usize,

        /// Output directory for logs and metrics
        #[arg(short, long, default_value = "output/simulation")]
        output_dir: String,

        /// Use CUDA backend
        #[arg(long, default_value = "false")]
        cuda: bool,
    },

    /// Export metrics and results
    Export {
        /// Path to metrics directory
        #[arg(short, long, default_value = "output")]
        input_dir: String,

        /// Output format (csv, json)
        #[arg(short, long, default_value = "csv")]
        format: String,

        /// Output file path
        #[arg(short, long)]
        output: String,
    },

    /// Show dataset statistics
    Stats {
        /// Path to the dataset directory
        #[arg(short, long, default_value = "data/plantvillage")]
        data_dir: String,

        /// Show split simulation info
        #[arg(long, default_value = "false")]
        show_splits: bool,
    },
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    // Initialize logging
    let log_config = if cli.verbose {
        LogConfig::verbose()
    } else {
        LogConfig::default()
    };

    let _ = init_logging(&log_config);

    // Print banner
    print_banner();

    // Execute command
    match cli.command {
        Commands::Download { output_dir } => {
            cmd_download(&output_dir)?;
        }

        Commands::Train {
            data_dir,
            epochs,
            batch_size,
            learning_rate,
            labeled_ratio,
            confidence_threshold,
            output_dir,
            cuda,
            seed,
        } => {
            run_training_simple(
                &data_dir,
                epochs,
                batch_size,
                learning_rate,
                labeled_ratio,
                confidence_threshold,
                &output_dir,
                seed,
            )?;
        }
        #[cfg(not(feature = "cuda"))]
        {
            println!(
                "{} CUDA feature not enabled. Compile with --features cuda",
                "Error:".red()
            );
            return Ok(());
        }
    } else {
        #[cfg(feature = "cpu")]
        {
            run_training_simple(
                &data_dir,
                epochs,
                batch_size,
                learning_rate,
                labeled_ratio,
                confidence_threshold,
                &output_dir,
                seed,
            )?;
        }
        #[cfg(not(feature = "cpu"))]
        {
            println!(
                "{} CPU feature not enabled. Compile with --features cpu",
                "Error:".red()
            );
            return Ok(());
        }
    }

    Ok(())
}

fn cmd_infer(input: &str, model: &str, cuda: bool) -> Result<()> {
    info!("Running inference");
    info!("  Input: {}", input);
    info!("  Model: {}", model);
    info!("  CUDA enabled: {}", cuda);

    println!("{}", "Inference Configuration:".cyan().bold());
    println!("  ğŸ“· Input:  {}", input);
    println!("  ğŸ§  Model:  {}", model);
    println!("  ğŸ–¥ï¸  Backend: {}", if cuda { "CUDA" } else { "CPU" });
    println!();

    // Check if paths exist
    if !Path::new(input).exists() {
        println!("{} Input path not found: {}", "Error:".red(), input);
        return Ok(());
    }

    if !Path::new(model).exists() {
        println!("{} Model path not found: {}", "Error:".red(), model);
        return Ok(());
    }

    println!("{} Inference not yet fully implemented.", "Note:".yellow());
    println!("  The Predictor struct in src/inference/predictor.rs provides the interface.");

    Ok(())
}

fn cmd_benchmark(model: &str, test_dir: &str, iterations: usize, cuda: bool) -> Result<()> {
    info!("Running benchmark");
    info!("  Model: {}", model);
    info!("  Test directory: {}", test_dir);
    info!("  Iterations: {}", iterations);
    info!("  CUDA enabled: {}", cuda);

    println!("{}", "Benchmark Configuration:".cyan().bold());
    println!("  ğŸ§  Model:      {}", model);
    println!("  ğŸ“ Test dir:   {}", test_dir);
    println!("  ğŸ”„ Iterations: {}", iterations);
    println!("  ğŸ–¥ï¸  Backend:    {}", if cuda { "CUDA" } else { "CPU" });
    println!();

    println!("{} Benchmarking not yet fully implemented.", "Note:".yellow());
    println!("  See src/inference/benchmark.rs for the benchmarking utilities.");
    println!("  Target latency: < 200ms per image on Jetson Orin Nano");

    Ok(())
}

#[allow(clippy::too_many_arguments)]
fn cmd_simulate(
    data_dir: &str,
    model: &str,
    days: usize,
    images_per_day: usize,
    confidence_threshold: f64,
    retrain_threshold: usize,
    output_dir: &str,
    cuda: bool,
) -> Result<()> {
    info!("Starting stream simulation");
    info!("  Data directory: {}", data_dir);
    info!("  Model: {}", model);
    info!("  Simulated days: {}", days);
    info!("  Images per day: {}", images_per_day);
    info!("  Confidence threshold: {}", confidence_threshold);
    info!("  Retrain threshold: {} images", retrain_threshold);
    info!("  Output directory: {}", output_dir);
    info!("  CUDA enabled: {}", cuda);

    println!("{}", "Simulation Configuration:".cyan().bold());
    println!("  ğŸ“ Data directory:     {}", data_dir);
    println!("  ğŸ§  Initial model:      {}", model);
    println!("  ğŸ“… Simulated days:     {}", days);
    println!("  ğŸ“· Images per day:     {}", images_per_day);
    println!("  ğŸ¯ Confidence threshold: {}", confidence_threshold);
    println!("  ğŸ”„ Retrain threshold:  {} images", retrain_threshold);
    println!("  ğŸ’¾ Output directory:   {}", output_dir);
    println!("  ğŸ–¥ï¸  Backend:            {}", if cuda { "CUDA" } else { "CPU" });
    println!();

    println!("{}", "Simulation Flow:".yellow());
    println!("  Day 1-{}: Simulate camera capturing {} images/day", days, images_per_day);
    println!("  â€¢ Model predicts labels for each 'captured' image");
    println!("  â€¢ High-confidence predictions (>= {}) become pseudo-labels", confidence_threshold);
    println!("  â€¢ After {} pseudo-labels, retrain the model", retrain_threshold);
    println!("  â€¢ Track pseudo-label precision (we know ground truth!)");
    println!("  â€¢ Report accuracy improvement over time");
    println!();

    println!("{} Simulation not yet fully implemented.", "Note:".yellow());
    println!("  See src/training/pseudo_label.rs for the stream simulator.");

    Ok(())
}

fn cmd_export(input_dir: &str, format: &str, output: &str) -> Result<()> {
    info!("Exporting metrics");
    info!("  Input directory: {}", input_dir);
    info!("  Format: {}", format);
    info!("  Output: {}", output);

    println!("{}", "Export Configuration:".cyan().bold());
    println!("  ğŸ“ Input directory: {}", input_dir);
    println!("  ğŸ“„ Format:          {}", format);
    println!("  ğŸ’¾ Output:          {}", output);
    println!();

    let valid_formats = ["csv", "json"];
    if !valid_formats.contains(&format) {
        println!(
            "{} Invalid format '{}'. Use one of: {:?}",
            "Error:".red(),
            format,
            valid_formats
        );
        return Ok(());
    }

    println!("{} Export not yet fully implemented.", "Note:".yellow());
    println!("  Metrics can be exported from:");
    println!("    â€¢ Training logs (loss, accuracy per epoch)");
    println!("    â€¢ Confusion matrices");
    println!("    â€¢ Pseudo-label precision over time");
    println!("    â€¢ Benchmark results");

    Ok(())
}
